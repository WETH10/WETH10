{
  "language": "Solidity",
  "sources": {
    "contracts/fuzzing/WETH10Fuzzing.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.7.6;\nimport \"../WETH10.sol\";\n\n\n/// @dev A contract that will receive weth, and allows for it to be retrieved.\ncontract MockHolder {\n    constructor (address payable weth, address retriever) {\n        WETH10(weth).approve(retriever, type(uint).max);\n    }\n}\n\n/// @dev Invariant testing\ncontract WETH10Fuzzing {\n\n    WETH10 internal weth;\n    address internal holder;\n\n    /// @dev Instantiate the WETH10 contract, and a holder address that will return weth when asked to.\n    constructor () {\n        weth = new WETH10();\n        holder = address(new MockHolder(address(weth), address(this)));\n    }\n\n    /// @dev Receive ETH when withdrawing.\n    receive () external payable { }\n\n    /// @dev Add two numbers, but return 0 on overflow\n    function add(uint a, uint b) internal pure returns (uint c) {\n        c = a + b;\n        assert(c >= a); // Normally it would be a `require`, but we want the test to fail if there is an overflow, not to be ignored.\n    }\n\n    /// @dev Subtract two numbers, but return 0 on overflow\n    function sub(uint a, uint b) internal pure returns (uint c) {\n        c = a - b;\n        assert(c <= a); // Normally it would be a `require`, but we want the test to fail if there is an overflow, not to be ignored.\n    }\n\n    /// @dev Test that supply and balance hold on deposit.\n    function deposit(uint ethAmount) public {\n        uint supply = address(weth).balance;\n        uint balance = weth.balanceOf(address(this));\n        weth.deposit{value: ethAmount}(); // It seems that echidna won't let the total value sent go over type(uint256).max\n        assert(address(weth).balance == add(supply, ethAmount));\n        assert(weth.balanceOf(address(this)) == add(balance, ethAmount));\n        assert(address(weth).balance == address(weth).balance);\n    }\n\n    /// @dev Test that supply and balance hold on withdraw.\n    function withdraw(uint ethAmount) public {\n        uint supply = address(weth).balance;\n        uint balance = weth.balanceOf(address(this));\n        weth.withdraw(ethAmount);\n        assert(address(weth).balance == sub(supply, ethAmount));\n        assert(weth.balanceOf(address(this)) == sub(balance, ethAmount));\n        assert(address(weth).balance == address(weth).balance);\n    }\n\n    /// @dev Test that supply and balance hold on transfer.\n    function transfer(uint ethAmount) public {\n        uint thisBalance = weth.balanceOf(address(this));\n        uint holderBalance = weth.balanceOf(holder);\n        weth.transfer(holder, ethAmount);\n        assert(weth.balanceOf(address(this)) == sub(thisBalance, ethAmount));\n        assert(weth.balanceOf(holder) == add(holderBalance, ethAmount));\n        assert(address(weth).balance == address(weth).balance);\n    }\n\n    /// @dev Test that supply and balance hold on transferFrom.\n    function transferFrom(uint ethAmount) public {\n        uint thisBalance = weth.balanceOf(address(this));\n        uint holderBalance = weth.balanceOf(holder);\n        weth.transferFrom(holder, address(this), ethAmount);\n        assert(weth.balanceOf(address(this)) == add(thisBalance, ethAmount));\n        assert(weth.balanceOf(holder) == sub(holderBalance, ethAmount));\n        assert(address(weth).balance == address(weth).balance);\n    }\n}"
    },
    "contracts/WETH10.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n// Adapted by Ethereum Community 2020\npragma solidity 0.7.6;\n\nimport \"./interfaces/IWETH10.sol\";\nimport \"./interfaces/IERC3156FlashBorrower.sol\";\n\ninterface ITransferReceiver {\n    function onTokenTransfer(address, uint, bytes calldata) external returns (bool);\n}\n\ninterface IApprovalReceiver {\n    function onTokenApproval(address, uint, bytes calldata) external returns (bool);\n}\n\n\n/// @dev WETH10 is an Ether ERC20 wrapper. You can `deposit` Ether and obtain Wrapped Ether which can then be operated as an ERC20 token. You can\n/// `withdraw` Ether from WETH10, which will burn Wrapped Ether in your wallet. The amount of Wrapped Ether in any wallet is always identical to the\n/// balance of Ether deposited minus the Ether withdrawn with that specific wallet.\ncontract WETH10 is IWETH10 {\n\n    string public constant name = \"Wrapped Ether v10\";\n    string public constant symbol = \"WETH10\";\n    uint8  public constant decimals = 18;\n\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /// @dev Records amount of WETH10 token owned by account.\n    mapping (address => uint256) public override balanceOf;\n\n    /// @dev Records current ERC2612 nonce for account. This value must be included whenever signature is generated for {permit}.\n    /// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.\n    mapping (address => uint256) public override nonces;\n\n    /// @dev Records number of WETH10 token that account (second) will be allowed to spend on behalf of another account (first) through {transferFrom}.\n    mapping (address => mapping (address => uint256)) public override allowance;\n\n    /// @dev Current amount of flash minted WETH.\n    uint256 public override flashMinted;\n\n    /// @dev Fallback, `msg.value` of ether sent to contract grants caller account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to caller account.\n    receive() external payable {\n        _mintTo(msg.sender, msg.value);\n    }\n\n    /// @dev Returns the total supply of WETH10 as the Ether held in this contract.\n    function totalSupply() external view override returns(uint256) {\n        return address(this).balance + flashMinted;\n    }\n\n    /// @dev `msg.value` of ether sent to contract grants caller account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to caller account.\n    function deposit() external override payable {\n        _mintTo(msg.sender, msg.value);\n    }\n\n    /// @dev `msg.value` of ether sent to contract grants `to` account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to `to` account.\n    function depositTo(address to) external override payable {\n        _mintTo(to, msg.value);\n    }\n\n\n    /// @dev `msg.value` of ether sent to contract grants `to` account a matching increase in WETH10 token balance,\n    /// after which a call is executed to an ERC677-compliant contract.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token and transfer to account (`to`) cannot cause overflow.\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function depositToAndCall(address to, bytes calldata data) external override payable returns (bool success) {\n        _mintTo(to, msg.value);\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, msg.value, data);\n    }\n\n    /// @dev Return the amount of WETH10 that can be flash lended.\n    function maxFlashAmount(address token) external view override returns (uint256) {\n        return token == address(this) ? type(uint112).max - address(this).balance - flashMinted : 0; // Can't underflow - L108\n    }\n\n    /// @dev Return the fee (zero) for flash lending an amount of WETH10.\n    function flashFee(address token, uint256) external view override returns (uint256) {\n        require(token == address(this), \"WETH: flash mint only WETH10\");\n        return 0;\n    }\n\n    /// @dev Flash lends `value` WETH10 tokens to the receiver address.\n    /// By the end of the transaction, `value` WETH10 tokens will be burned from the receiver.\n    /// The flash minted WETH10 is not backed by real Ether, but can be withdrawn as such up to the Ether balance of this contract.\n    /// Arbitrary data can be passed as a bytes calldata parameter.\n    /// Emits two {Transfer} events for minting and burning of the flash minted amount.\n    function flashLoan(address receiver, address token, uint256 value, bytes calldata data) external override {\n        require(token == address(this), \"WETH: flash mint only WETH10\");\n        flashMinted += value;\n        _mintTo(receiver, value);\n\n        IERC3156FlashBorrower(receiver).onFlashLoan(msg.sender, address(this), value, 0, data);\n\n        _decreaseAllowance(receiver, address(this), value);\n        _burnFrom(receiver, value);\n        flashMinted -= value;\n    }\n\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ether to the same.\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account. \n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function withdraw(uint256 value) external override {\n        _burnFrom(msg.sender, value);\n        _transferEther(msg.sender, value);\n    }\n\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ether to account (`to`).\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account.\n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function withdrawTo(address payable to, uint256 value) external override {\n        _burnFrom(msg.sender, value);\n        _transferEther(to, value);\n    }\n\n    /// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ether to account (`to`).\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n    /// unless allowance is set to `type(uint256).max`\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to zero address from account (`from`).\n    /// Requirements:\n    ///   - `from` account must have at least `value` balance of WETH10 token.\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\n    function withdrawFrom(address from, address payable to, uint256 value) external override {\n        if (from != msg.sender) _decreaseAllowance(from, msg.sender, value);\n        _burnFrom(from, value);\n        _transferEther(to, value);\n    }\n\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Approval} event.\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token,\n    /// after which a call is executed on `spender` with the `data` parameter.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Approval} event.\n    /// For more information on approveAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);\n    }\n\n    /// @dev Sets `value` as allowance of `spender` account over `owner` account's WETH10 token, given `owner` account's signed approval.\n    /// Emits {Approval} event.\n    /// Requirements:\n    ///   - `deadline` must be timestamp in future.\n    ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.\n    ///   - the signature must use `owner` account's current nonce (see {nonces}).\n    ///   - the signer cannot be zero address and must be `owner` account.\n    /// For more information on signature format, see https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section].\n    /// WETH10 token implementation adapted from https://github.com/albertocuestacanada/ERC20Permit/blob/master/contracts/ERC20Permit.sol.\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\n        require(block.timestamp <= deadline, \"WETH: Expired permit\");\n\n        uint256 chainId;\n        assembly {chainId := chainid()}\n        bytes32 DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)));\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                value,\n                nonces[owner]++,\n                deadline));\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                hashStruct));\n\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0) && signer == owner, \"WETH: invalid permit\");\n        _approve(owner, spender, value);\n    }\n\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`).\n    /// A transfer to `address(0)` triggers a withdraw of the sent tokens.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token.\n    function transfer(address to, uint256 value) external override returns (bool) {\n        return _transferFrom(msg.sender, to, value);\n    }\n\n    /// @dev Moves `value` WETH10 token from account (`from`) to account (`to`) using allowance mechanism.\n    /// `value` is then deducted from caller account's allowance, unless set to `type(uint256).max`.\n    /// A transfer to `address(0)` triggers a withdraw of the sent tokens in favor of caller.\n    /// Returns boolean value indicating whether operation succeeded.\n    ///\n    /// Emits {Transfer} and {Approval} events.\n    /// Requirements:\n    /// - owner account (`from`) must have at least `value` WETH10 token.\n    /// - caller account must have at least `value` allowance from account (`from`).\n    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\n        if (from != msg.sender) _decreaseAllowance(from, msg.sender, value);\n        return _transferFrom(from, to, value);\n    }\n\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`), after which a call is executed to an ERC677-compliant contract.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token.\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function transferAndCall(address to, uint value, bytes calldata data) external override returns (bool) {\n        _transferFrom(msg.sender, to, value);\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);\n    }\n\n    /// @dev Sets `value` as allowance of `spender` account over `owner` account's WETH10 token.\n    /// Emits {Approval} event.\n    function _approve(address owner, address spender, uint256 value) internal {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /// @dev Decreases the allowance of `spender` account over `owner` account's by `value` WETH10 token.\n    /// If the allowance of `spender` account over `owner` account's is type(uin112).max WETH10 token this function does nothing.\n    /// Emits {Approval} event.\n    /// Requirements:\n    /// - allowance of `spender` account over `owner must be at least `value` WETH10 token.\n    function _decreaseAllowance(address owner, address spender, uint256 value) internal {\n        uint256 allowed = allowance[owner][spender];\n        if (allowed != type(uint256).max) {\n            require(allowed >= value, \"WETH: request exceeds allowance\");\n            _approve(owner, spender, allowed - value);\n        }\n    }\n\n    /// @dev Moves `value` WETH10 token from account (`from`) to account (`to`) using allowance mechanism.\n    /// `value` is then deducted from caller account's allowance, unless set to `type(uint256).max`.\n    /// A transfer to `address(0)` triggers a withdraw of the sent tokens in favor of caller.\n    /// Returns boolean value indicating whether operation succeeded.\n    ///\n    /// Emits {Transfer} and {Approval} events.\n    /// Requirements:\n    /// - owner account (`from`) must have at least `value` WETH10 token.\n    /// - caller account must have at least `value` allowance from account (`from`).\n    function _transferFrom(address from, address to, uint256 value) internal returns (bool) {\n        if(to != address(0)) { // Transfer\n            uint256 balance = balanceOf[from];\n            require(balance >= value, \"WETH: transfer amount exceeds balance\");\n\n            balanceOf[from] = balance - value;\n            balanceOf[to] += value;\n            emit Transfer(from, to, value);\n        } else { // Withdraw\n            _burnFrom(from, value);\n            _transferEther(payable(to), value);\n        }\n        \n        return true;\n    }\n\n    /// @dev Transfers `value` Ether to account (`to`).\n    function _transferEther(address payable to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(\"\");\n        require(success, \"WETH: Ether transfer failed\");\n    }\n\n    /// @dev Creates `value` WETH10 token on account (`to`).\n    /// Requirements:\n    /// - The resulting WETH10 supply must remain below type(uint112).max.\n    ///\n    /// Emits {Transfer} event.\n    function _mintTo(address to, uint256 value) internal {\n        require(address(this).balance + flashMinted <= type(uint112).max, \"WETH: supply limit exceeded\");\n        balanceOf[to] += value;\n        emit Transfer(address(0), to, value);\n    }\n\n    /// @dev Destroys `value` WETH10 token from account (`from`) using allowance mechanism.\n    /// `value` is then deducted from caller account's allowance, unless set to `type(uint256).max`.\n    ///\n    /// Emits {Transfer} and {Approval} events.\n    /// Requirements:\n    /// - owner account (`from`) must have at least `value` WETH10 token.\n    /// - caller account must have at least `value` allowance from account (`from`).\n    function _burnFrom(address from, uint256 value) internal {\n        uint256 balance = balanceOf[from];\n        require(balance >= value, \"WETH: burn amount exceeds balance\");\n        balanceOf[from] = balance - value;\n        emit Transfer(from, address(0), value);\n    }\n}\n\n"
    },
    "contracts/interfaces/IWETH10.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n// Adapted by Ethereum Community 2020\npragma solidity 0.7.6;\nimport \"./IERC20.sol\";\nimport \"./IERC2612.sol\";\nimport \"./IERC3156FlashLender.sol\";\n\n\n/// @dev WETH10 is an Ether ERC20 wrapper. You can `deposit` Ether and obtain Wrapped Ether which can then be operated as an ERC20 token. You can\n/// `withdraw` Ether from WETH10, which will burn Wrapped Ether in your wallet. The amount of Wrapped Ether in any wallet is always identical to the\n/// balance of Ether deposited minus the Ether withdrawn with that specific wallet.\ninterface IWETH10 is IERC20, IERC2612, IERC3156FlashLender {\n\n    /// @dev Returns current amount of flash minted WETH10 token.\n    function flashMinted() external view returns(uint256);\n\n    /// @dev `msg.value` of ether sent to contract grants caller account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to caller account.\n    function deposit() external payable;\n\n    /// @dev `msg.value` of ether sent to contract grants `to` account a matching increase in WETH10 token balance.\n    /// Emits {Transfer} event to reflect WETH10 token mint of `msg.value` from zero address to `to` account.\n    function depositTo(address to) external payable;\n\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ether to the same.\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account. \n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function withdraw(uint256 value) external;\n\n    /// @dev Burn `value` WETH10 token from caller account and withdraw matching ether to account (`to`).\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` WETH10 token to zero address from caller account.\n    /// Requirements:\n    ///   - caller account must have at least `value` balance of WETH10 token.\n    function withdrawTo(address payable to, uint256 value) external;\n\n    /// @dev Burn `value` WETH10 token from account (`from`) and withdraw matching ether to account (`to`).\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\n    /// unless allowance is set to `type(uint256).max`\n    /// Emits {Transfer} event to reflect WETH10 token burn of `value` to zero address from account (`from`).\n    /// Requirements:\n    ///   - `from` account must have at least `value` balance of WETH10 token.\n    ///   - `from` account must have approved caller to spend at least `value` of WETH10 token, unless `from` and caller are the same account.\n    function withdrawFrom(address from, address payable to, uint256 value) external;\n\n    /// @dev `msg.value` of ether sent to contract grants `to` account a matching increase in WETH10 token balance,\n    /// after which a call is executed to an ERC677-compliant contract.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token and transfer to account (`to`) cannot cause overflow.\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function depositToAndCall(address to, bytes calldata data) external payable returns (bool);\n\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WETH10 token,\n    /// after which a call is executed on `spender` with the `data` parameter.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Approval} event.\n    /// For more information on approveAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n\n    /// @dev Moves `value` WETH10 token from caller's account to account (`to`), after which a call is executed to an ERC677-compliant contract.\n    /// Returns boolean value indicating whether operation succeeded.\n    /// Emits {Transfer} event.\n    /// Requirements:\n    ///   - caller account must have at least `value` WETH10 token.\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\n    function transferAndCall(address to, uint value, bytes calldata data) external returns (bool);\n}\n\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\npragma solidity ^0.7.6;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.7.6;\n\ninterface IERC3156FlashLender {\n    function flashLoan(address receiver, address token, uint256 value, bytes calldata) external;\n    function flashFee(address token, uint256 value) external view returns (uint256);\n    function maxFlashAmount(address token) external view returns (uint256);\n}"
    },
    "contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.7.6;\n\n\ninterface IERC3156FlashBorrower {\n    function onFlashLoan(address user, address token, uint256 value, uint256 fee, bytes calldata) external;\n}"
    },
    "contracts/tests/TestFlashMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.7.6;\n\nimport \"../interfaces/IWETH10.sol\";\nimport \"../interfaces/IERC3156FlashBorrower.sol\";\n\n\ncontract TestFlashLender is IERC3156FlashBorrower {\n    enum Action {NORMAL, STEAL, WITHDRAW, REENTER}\n\n    uint256 public flashBalance;\n    address public flashToken;\n    uint256 public flashValue;\n    address public flashSender;\n\n    receive() external payable {}\n\n    function onFlashLoan(address sender, address token, uint256 value, uint256, bytes calldata data) external override {\n        address lender = msg.sender;\n        (Action action) = abi.decode(data, (Action)); // Use this to unpack arbitrary data\n        flashSender = sender;\n        flashToken = token;\n        flashValue = value;\n        if (action == Action.NORMAL) {\n            flashBalance = IWETH10(lender).balanceOf(address(this));\n        } else if (action == Action.WITHDRAW) {\n            IWETH10(lender).withdraw(value);\n            flashBalance = address(this).balance;\n            IWETH10(lender).deposit{ value: value }();\n        } else if (action == Action.STEAL) {\n            // Do nothing\n        } else if (action == Action.REENTER) {\n            bytes memory data = abi.encode(Action.NORMAL);\n            IWETH10(lender).approve(lender, IWETH10(lender).allowance(address(this), lender) + value * 2);\n            IWETH10(lender).flashLoan(address(this), address(lender), value * 2, data);\n        }\n    }\n\n    function flashLoan(address lender, uint256 value) public {\n        // Use this to pack arbitrary data to `onFlashLoan`\n        bytes memory data = abi.encode(Action.NORMAL);\n        IWETH10(lender).approve(lender, value);\n        IWETH10(lender).flashLoan(address(this), address(lender), value, data);\n    }\n\n    function flashLoanAndWithdraw(address lender, uint256 value) public {\n        // Use this to pack arbitrary data to `onFlashLoan`\n        bytes memory data = abi.encode(Action.WITHDRAW);\n        IWETH10(lender).approve(lender, value);\n        IWETH10(lender).flashLoan(address(this), address(lender), value, data);\n    }\n\n    function flashLoanAndSteal(address lender, uint256 value) public {\n        // Use this to pack arbitrary data to `onFlashLoan`\n        bytes memory data = abi.encode(Action.STEAL);\n        IWETH10(lender).flashLoan(address(this), address(lender), value, data);\n    }\n\n    function flashLoanAndReenter(address lender, uint256 value) public {\n        // Use this to pack arbitrary data to `onFlashLoan`\n        bytes memory data = abi.encode(Action.REENTER);\n        IWETH10(lender).approve(lender, value);\n        IWETH10(lender).flashLoan(address(this), address(lender), value, data);\n    }\n}\n"
    },
    "contracts/tests/TestTransferReceiver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub / adapted by [] 2020\npragma solidity 0.7.6;\n\n\ncontract TestTransferReceiver {\n    address public token;\n\n    event TransferReceived(address token, address sender, uint256 value, bytes data);\n    event ApprovalReceived(address token, address spender, uint256 value, bytes data);\n\n    function onTokenTransfer(address sender, uint value, bytes calldata data) external returns(bool) {\n        emit TransferReceived(msg.sender, sender, value, data);\n        return true;\n    }\n\n    function onTokenApproval(address spender, uint value, bytes calldata data) external returns(bool) {\n        emit ApprovalReceived(msg.sender, spender, value, data);\n        return true;\n    }\n}\n"
    },
    "contracts/tests/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.6;\n\ncontract WETH9 {\n    string public name     = \"Wrapped Ether\";\n    string public symbol   = \"WETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    receive() external payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        msg.sender.transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}"
    },
    "contracts/WethConverter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// Copyright (C) 2015, 2016, 2017 Dapphub\n// Adapted by Ethereum Community 2020\npragma solidity 0.7.6;\n\n\ninterface WETH9Like {\n    function withdraw(uint) external payable;\n    function deposit() external payable;\n    function transfer(address, uint) external returns (bool);\n    function transferFrom(address, address, uint) external returns (bool);\n}\n\ninterface WETH10Like {\n    function depositTo(address) external payable;\n    function withdrawFrom(address, address, uint256) external payable;\n}\n\ncontract WethConverter {\n\n    receive() external payable {\n    }\n\n    function weth9ToWeth10(WETH9Like weth9, WETH10Like weth10, address account, uint256 value) public {\n        weth9.transferFrom(account, address(this), value);\n        weth9.withdraw(value);\n        weth10.depositTo{ value: value }(account);\n    }\n\n    function weth10ToWeth9(WETH9Like weth9, WETH10Like weth10, address account, uint256 value) public {\n        weth10.withdrawFrom(account, address(this), value);\n        weth9.deposit{ value: value }();\n        weth9.transfer(account, value);\n    }\n}\n\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 20000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}